import { ConfigService } from 'nestjs-config';
import { Test } from '@nestjs/testing';
import { UserRole } from '@fc/shared/user/roles.enum';
import { LocalsInterceptor } from './locals.interceptor';

describe('LocalsInterceptor', () => {
  let localsInterceptor;
  const configService = {
    get: jest.fn(),
  };

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [LocalsInterceptor, ConfigService],
    })
      .overrideProvider(ConfigService)
      .useValue(configService)
      .compile();
    localsInterceptor = await module.get<LocalsInterceptor>(LocalsInterceptor);
  });

  it('should add the FCA meta information to all responses', async () => {
    const req = {
      user: 'jean_moust',
    };
    const res: any = {
      locals: {},
    };
    const currentBranch = 'testing';
    const shortHash = '3f17f344';
    const longHash = '3f17f344448066d75f9eb33ade5fdcd799d89352';
    const context = {
      switchToHttp: jest.fn(() => ({
        getRequest: jest.fn(() => req),
        getResponse: jest.fn(() => res),
      })),
    };
    const next = {
      handle: jest.fn(),
    };
    configService.get.mockReturnValueOnce({
      environment: 'testing',
      commitUrlPrefix:
        'https://gitlab.com/france-connect/FranceConnect/commit/',
      currentBranch,
      latestCommitShortHash: shortHash,
      latestCommitLongHash: longHash,
      app_root: '/foo/bar',
      instanceFor: 'FCA',
    });

    await localsInterceptor.intercept(context, next);

    expect(configService.get).toBeCalledWith('app');
    expect(res.locals.APP_ENVIRONMENT).toBe('testing');
    expect(res.locals.APP_ROOT).toBe('/foo/bar');
    expect(res.locals.COMMIT_URL_PREFIX).toBe(
      'https://gitlab.com/france-connect/FranceConnect/commit/',
    );
    expect(res.locals.GIT_CURRENT_BRANCH).toBe(currentBranch);
    expect(res.locals.GIT_LATEST_COMMIT_SHORT_HASH).toBe(shortHash);
    expect(res.locals.GIT_LATEST_COMMIT_LONG_HASH).toBe(longHash);
    expect(res.locals.CURRENT_USER).toBe(req.user);
    expect(next.handle).toBeCalledTimes(1);
    expect(res.locals.USER_ROLES_OPTIONS).toEqual([
      { label: 'Administrateur', value: UserRole.ADMIN },
      { label: 'Exploitant', value: UserRole.OPERATOR },
      { label: 'Sécurité', value: UserRole.SECURITY },
      { label: 'Nouvel utilisateur', value: UserRole.NEWUSER },
      { label: 'Administrateur inactif', value: UserRole.INACTIVE_ADMIN },
      { label: 'Exploitant inactif', value: UserRole.INACTIVE_OPERATOR },
      { label: 'Sécurité inactif', value: UserRole.INACTIVE_SECURITY },
      { label: 'Utilisateur bloqué', value: UserRole.BLOCKED_USER },
    ]);
  });

  it('should add the FC meta information to all responses', async () => {
    const req = {
      user: 'jean_moust',
    };
    const res: any = {
      locals: {},
    };
    const currentBranch = 'testing';
    const shortHash = '3f17f344';
    const longHash = '3f17f344448066d75f9eb33ade5fdcd799d89352';
    const context = {
      switchToHttp: jest.fn(() => ({
        getRequest: jest.fn(() => req),
        getResponse: jest.fn(() => res),
      })),
    };
    const next = {
      handle: jest.fn(),
    };
    configService.get.mockReturnValueOnce({
      environment: 'testing',
      commitUrlPrefix:
        'https://gitlab.com/france-connect/FranceConnect/commit/',
      currentBranch,
      latestCommitShortHash: shortHash,
      latestCommitLongHash: longHash,
      app_root: '/foo/bar',
      instanceFor: 'FC',
    });

    await localsInterceptor.intercept(context, next);

    expect(configService.get).toBeCalledWith('app');
    expect(res.locals.APP_ENVIRONMENT).toBe('testing');
    expect(res.locals.APP_ROOT).toBe('/foo/bar');
    expect(res.locals.COMMIT_URL_PREFIX).toBe(
      'https://gitlab.com/france-connect/FranceConnect/commit/',
    );
    expect(res.locals.GIT_CURRENT_BRANCH).toBe(currentBranch);
    expect(res.locals.GIT_LATEST_COMMIT_SHORT_HASH).toBe(shortHash);
    expect(res.locals.GIT_LATEST_COMMIT_LONG_HASH).toBe(longHash);
    expect(res.locals.CURRENT_USER).toBe(req.user);
    expect(next.handle).toBeCalledTimes(1);
    expect(res.locals.USER_ROLES_OPTIONS).toEqual([
      { label: 'Administrateur', value: UserRole.ADMIN },
      { label: 'Exploitant', value: UserRole.OPERATOR },
      { label: 'Sécurité', value: UserRole.SECURITY },
      { label: 'Nouvel utilisateur', value: UserRole.NEWUSER },
      { label: 'Administrateur inactif', value: UserRole.INACTIVE_ADMIN },
      { label: 'Exploitant inactif', value: UserRole.INACTIVE_OPERATOR },
      { label: 'Sécurité inactif', value: UserRole.INACTIVE_SECURITY },
      { label: 'Utilisateur bloqué', value: UserRole.BLOCKED_USER },
    ]);
  });
});
