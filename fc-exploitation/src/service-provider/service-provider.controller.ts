import { Repository } from 'typeorm';

import {
  Controller,
  Get,
  Render,
  Post,
  Body,
  UseInterceptors,
  UsePipes,
  Req,
  Res,
  Param,
  Query,
  Delete,
  ValidationPipe,
  Patch,
} from '@nestjs/common';
import { plainToClass } from 'class-transformer';
import { InjectRepository } from '@nestjs/typeorm';
import { UserRole } from '@fc/shared/user/roles.enum';
import { Roles } from '@fc/shared/authentication/decorator/roles.decorator';
import { FormErrorsInterceptor } from '@fc/shared/form/interceptor/form-errors.interceptor';
import {
  nullableArrayToDefaultNoneOrLines,
  arrayToLines,
} from '@fc/shared/transforms/string.transform';
import { ScopesService } from '../scopes';
import { Claims, ClaimsService } from '../claims';
import { ServiceProvider } from './service-provider.mongodb.entity';
import { ServiceProviderService } from './service-provider.service';
import { ServiceProviderDto } from './dto/service-provider-input.dto';
import { DeleteServiceProviderDto } from './dto/delete-service-provider.dto';
import { GenerateNewClientSecretDTO } from './dto/generate-new-client-secret.dto';

@Controller('service-provider')
export class ServiceProviderController {
  constructor(
    @InjectRepository(ServiceProvider, 'fc-mongo')
    private readonly serviceProviderRepository: Repository<ServiceProvider>,
    private readonly serviceProviderService: ServiceProviderService,
    private readonly scopesService: ScopesService,
    private readonly claimsService: ClaimsService,
  ) {}

  /**
   *
   * @param req
   * @param search
   * @param sort
   * @param action
   * @param pageQuery
   * @param limitQuery
   */
  @Get()
  @Roles(UserRole.OPERATOR, UserRole.SECURITY)
  @Render('service-provider/list')
  async list(
    @Req() req,
    @Query('search') search: string,
    @Query('sort') sort: string,
    @Query('action') action: string,
    @Query('page') pageQuery: string = '1',
    @Query('limit') limitQuery: string = '10',
  ) {
    const activeServiceProvidersCount = await this.serviceProviderRepository.count(
      { active: true },
    );

    const page = parseInt(pageQuery, 10);
    const limit = parseInt(limitQuery, 10);
    const csrfToken = req.csrfToken();
    const userSearch = search;

    const serviceProviders = await this.serviceProviderService.paginate({
      page,
      limit,
      route: '/service-provider',
      sort,
      action,
      defaultLimit: 10,
      userSearch,
    });
    return {
      serviceProviders: serviceProviders.items,
      total: serviceProviders.total,
      activeServiceProvidersCount,
      csrfToken,
      page,
      limit,
      sort,
      action,
      userSearch,
    };
  }

  /**
   * Fournit le formulaire de création d'un fournisseur de service.
   *
   * @param {ParameterDecorator} req
   * @return {string} crsf token
   */
  @Get('create')
  @Render('service-provider/creation')
  @Roles(UserRole.OPERATOR)
  async showCreationForm(@Req() req) {
    const csrfToken = req.csrfToken();
    const scopesGroupedByFd = await this.scopesService.getScopesGroupedByFd();

    const claims: Claims[] = await this.claimsService.getAll();

    const response = {
      csrfToken,
      scopesGroupedByFd,
      claims,
      claimsSelected: ['amr'],
    };

    return response;
  }

  /**
   * Récupère les données du formulaire de création d'un fournisseur de service
   * @param createServiceProviderDto
   * @param req
   * @param res
   */
  @Post('create')
  @Roles(UserRole.OPERATOR)
  @UseInterceptors(new FormErrorsInterceptor(`/service-provider/create`))
  @UsePipes(new ValidationPipe({ transform: true, whitelist: true }))
  async createServiceProvider(
    @Body() createServiceProviderDto: ServiceProviderDto,
    @Req() req,
    @Res() res,
  ) {
    const spName = createServiceProviderDto.name;
    try {
      await this.serviceProviderService.createServiceProvider(
        createServiceProviderDto,
        req.user.username,
      );
    } catch (error) {
      req.flash(
        'globalError',
        "Impossible d'enregistrer le fournisseur de service",
      );
      req.flash('values', createServiceProviderDto);

      return res.redirect(`${res.locals.APP_ROOT}/service-provider/create`);
    }
    req.flash(
      'success',
      `Le fournisseur de service ${spName} a été créé avec succès !`,
    );

    return res.redirect(`${res.locals.APP_ROOT}/`);
  }

  /**
   *  Permet d'afficher la page d'un service-provider à modifier
   * @param id
   * @param req
   * @param res
   */
  @Get(':id')
  @Roles(UserRole.OPERATOR)
  @Render('service-provider/update')
  async findOne(@Param('id') id, @Req() req) {
    const csrfToken = req.csrfToken();

    const serviceProvider = await this.serviceProviderService.findById(id);
    const output = {
      ...serviceProvider,
      jwksUri: serviceProvider.jwks_uri,
      redirectUri: arrayToLines(serviceProvider.redirect_uris),
      site: arrayToLines(serviceProvider.site),
      ipsRanges: arrayToLines(serviceProvider.IPServerAddressesAndRanges),
      postLogoutUri: arrayToLines(serviceProvider.post_logout_redirect_uris),
      emails: Array.isArray(serviceProvider.email)
        ? arrayToLines(serviceProvider.email)
        : this.formatEmailFields(serviceProvider.email),
      response_types: nullableArrayToDefaultNoneOrLines(
        serviceProvider.response_types,
      ),
      grant_types: nullableArrayToDefaultNoneOrLines(
        serviceProvider.grant_types,
      ),
    };

    /**
     * We want to send to the view all the fields that the user
     * has updated if there was an error plus all the fields
     * that were not updated.
     */
    if (req.session.flash && req.session.flash.errors) {
      Object.assign(req.session.flash.values[0], output);
    } else {
      req.flash('values', output);
    }

    const scopesSelected: string[] = serviceProvider.scopes || [];
    const scopesGroupedByFd = await this.scopesService.getScopesGroupedByFd();

    const claimsSelected: string[] = serviceProvider.claims || ['amr'];
    const claims: Claims[] = await this.claimsService.getAll();

    const response = {
      csrfToken,
      id,
      claimsSelected,
      claims,
      scopesGroupedByFd,
      scopesSelected,
    };

    return response;
  }

  /**
   *
   * @param serviceProviderUpdate
   * @param id
   * @param req
   * @param res
   */
  @Patch(':id')
  @Roles(UserRole.OPERATOR)
  @UseInterceptors(new FormErrorsInterceptor(`/service-provider/:id`))
  @UsePipes(new ValidationPipe({ transform: true, whitelist: true }))
  async serviceProviderUpdate(
    @Body() updateServiceProviderDto: ServiceProviderDto,
    @Param('id') id,
    @Req() req,
    @Res() res,
  ) {
    const spName = updateServiceProviderDto.name;

    try {
      await this.serviceProviderService.update(
        id,
        updateServiceProviderDto,
        req.user.username,
      );
    } catch (error) {
      req.flash('globalError', 'Impossible de mettre à jour le FS');
      return res.redirect(`${res.locals.APP_ROOT}/service-provider/${id}`);
    }
    req.flash(
      'success',
      `Le fournisseur de service ${spName} a été modifié avec succès !`,
    );

    return res.redirect(`${res.locals.APP_ROOT}/service-provider/${id}`);
  }

  /**
   *
   * @param key
   * @param req
   * @param res
   * @param body
   */
  @Delete(':id')
  @Roles(UserRole.OPERATOR)
  @UseInterceptors(new FormErrorsInterceptor('/service-provider'))
  async deleteServiceProvider(
    @Param('id') id: string,
    @Req() req,
    @Res() res,
    @Body() body,
  ) {
    try {
      await this.serviceProviderService.deleteServiceProviderById(
        id,
        req.user.username,
      );
    } catch (error) {
      req.flash('globalError', error.message);
      return res.status(500);
    }
    req.flash(
      'success',
      `Le fournisseur de service ${body.name} a été supprimé avec succès !`,
    );
    return res.redirect(`${res.locals.APP_ROOT}/service-provider`);
  }

  /**
   *
   * @param deleteServiceProviderDto
   * @param res
   * @param req
   */
  @Post('delete')
  @Roles(UserRole.OPERATOR)
  @UsePipes(new ValidationPipe({ transform: true }))
  @UseInterceptors(new FormErrorsInterceptor('/service-provider'))
  async deleteServiceProviders(
    @Body() body: DeleteServiceProviderDto,
    @Res() res,
    @Req() req,
  ) {
    const { deleteItems = [], name } = body;
    try {
      await this.serviceProviderService.deleteManyServiceProvidersById(
        deleteItems,
        req.user.username,
      );
    } catch (error) {
      req.flash('globalError', error.message);
      return res.status(500);
    }
    req.flash(
      'success',
      `Les fournisseurs de service ${name} ont été supprimés avec succès !`,
    );
    return res.redirect(`${res.locals.APP_ROOT}/service-provider`);
  }

  /**
   *
   * @param id
   * @param req
   * @param res
   */
  @Get('update/:id/secret')
  @Roles(UserRole.OPERATOR)
  @Render('service-provider/generate-new-client-secret')
  async generateNewSecret(@Param('id') id: string, @Req() req, @Res() res) {
    const csrfToken = req.csrfToken();

    /**
     * If we have an error to flash, we want to render the last user inputs,
     * not the service-provider in database.
     */
    if (req.session.flash && req.session.flash.errors) {
      return {
        csrfToken,
        id,
      };
    }

    const serviceProvider = await this.serviceProviderService.findById(id);
    return {
      csrfToken,
      id,
      messages: {
        values: [serviceProvider],
      },
    };
  }

  /**
   *
   * @param id
   * @param generateNewClientSecretDTO
   * @param req
   * @param res
   */
  @Patch('update/:id/secret')
  @Roles(UserRole.OPERATOR)
  @UseInterceptors(
    new FormErrorsInterceptor('/service-provider/update/:id/secret'),
  )
  async generateNewClientSecret(
    @Param('id') id: string,
    @Body() generateNewClientSecretDTO: GenerateNewClientSecretDTO,
    @Req() req,
    @Res() res,
  ) {
    try {
      await this.serviceProviderService.generateNewSecret(
        id,
        req.user.username,
      );
    } catch (error) {
      req.flash('gobalError', error);
      return res.status(500);
    }

    req.flash(
      'success',
      `Le nouveau client secret du fournisseur de service ${generateNewClientSecretDTO.name} a été généré avec succés !`,
    );

    return res.redirect(`${res.locals.APP_ROOT}/service-provider`);
  }

  private formatEmailFields(emails: string): string {
    if (typeof emails !== 'string') {
      return '';
    }
    return emails.replace(/,/g, '\r\n');
  }
}
