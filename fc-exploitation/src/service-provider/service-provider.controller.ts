import { Repository } from 'typeorm';

import {
  Controller,
  Get,
  Render,
  Post,
  Body,
  UseInterceptors,
  UsePipes,
  Req,
  Res,
  Param,
  Query,
  Put,
  Delete,
  ValidationPipe,
  Patch,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { UserRole } from '@fc/shared/user/roles.enum';
import { Roles } from '@fc/shared/authentication/decorator/roles.decorator';
import { FormErrorsInterceptor } from '@fc/shared/form/interceptor/form-errors.interceptor';
import { ScopesService } from '../scopes';
import { Claims, ClaimsService } from '../claims';
import {
  IdentityProviderService,
  IIdentityProvider,
} from '../identity-provider';

import { ServiceProvider } from './service-provider.mongodb.entity';
import { ServiceProviderService } from './service-provider.service';
import { IServiceProvider } from './interface/service-provider.interface';
import { ServiceProviderDto } from './dto/service-provider-input.dto';
import { DeleteServiceProviderDto } from './dto/delete-service-provider.dto';
import { GenerateNewClientSecretDTO } from './dto/generate-new-client-secret.dto';

@Controller('service-provider')
export class ServiceProviderController {
  constructor(
    @InjectRepository(ServiceProvider, 'fc-mongo')
    private readonly serviceProviderRepository: Repository<ServiceProvider>,
    private readonly serviceProviderService: ServiceProviderService,
    private readonly scopesService: ScopesService,
    private readonly claimsService: ClaimsService,
    private readonly identityProviderService: IdentityProviderService,
  ) {}

  /**
   *
   * @param req
   * @param search
   * @param sort
   * @param action
   * @param pageQuery
   * @param limitQuery
   */
  @Get()
  @Roles(UserRole.OPERATOR, UserRole.SECURITY)
  @Render('service-provider/list')
  async list(
    @Req() req,
    @Query('search') search: string,
    @Query('sort') sort: string,
    @Query('action') action: string,
    @Query('page') pageQuery: string = '1',
    @Query('limit') limitQuery: string = '10',
  ) {
    const activeServiceProvidersCount = await this.serviceProviderRepository.count(
      { active: true },
    );

    const page = parseInt(pageQuery, 10);
    const limit = parseInt(limitQuery, 10);
    const csrfToken = req.csrfToken();
    const userSearch = search;

    const serviceProviders = await this.serviceProviderService.paginate({
      page,
      limit,
      route: '/service-provider',
      sort,
      action,
      defaultLimit: 10,
      userSearch,
    });
    return {
      serviceProviders: serviceProviders.items,
      total: serviceProviders.total,
      activeServiceProvidersCount,
      csrfToken,
      page,
      limit,
      sort,
      action,
      userSearch,
    };
  }

  /**
   * Fournit le formulaire de création d'un fournisseur de service.
   *
   * @param {ParameterDecorator} req
   * @return {string} crsf token
   */
  @Get('create')
  @Render('service-provider/creation')
  @Roles(UserRole.OPERATOR)
  async showCreationForm(@Req() req) {
    const csrfToken = req.csrfToken();
    const scopesGroupedByFd = await this.scopesService.getScopesGroupedByFd();

    const claims: Claims[] = await this.claimsService.getAll();

    const identityProviders: IIdentityProvider[] = await this.identityProviderService.getAll();

    const representativeScopeList = this.serviceProviderService.getRepresentativeScopeList();

    const response = {
      csrfToken,
      identityProviders,
      scopesGroupedByFd,
      claims,
      claimsSelected: ['amr'],
      representativeScopeList,
    };

    return response;
  }

  /**
   * Récupère les données du formulaire de création d'un fournisseur de service
   * @param createServiceProviderDto
   * @param req
   * @param res
   */
  @Post('create')
  @Roles(UserRole.OPERATOR)
  @UseInterceptors(new FormErrorsInterceptor(`/service-provider/create`))
  @UsePipes(new ValidationPipe({ transform: true, whitelist: true }))
  async createServiceProvider(
    @Body() createServiceProviderDto: ServiceProviderDto,
    @Req() req,
    @Res() res,
  ) {
    try {
      const serviceProvider: IServiceProvider = createServiceProviderDto as IServiceProvider;

      await this.serviceProviderService.createServiceProvider(
        serviceProvider,
        req.user.username,
      );
    } catch (error) {
      req.flash(
        'globalError',
        "Impossible d'enregistrer le fournisseur de service",
      );
      req.flash('values', createServiceProviderDto);

      return res.redirect(`${res.locals.APP_ROOT}/service-provider/create`);
    }
    req.flash(
      'success',
      `Le fournisseur de service ${createServiceProviderDto.name} a été créé avec succès !`,
    );

    return res.redirect(`${res.locals.APP_ROOT}/`);
  }

  /**
   *  Permet d'afficher la page d'un service-provider à modifier
   * @param id
   * @param req
   * @param res
   */
  @Get(':id')
  @Roles(UserRole.OPERATOR)
  @Render('service-provider/update')
  async findOne(@Param('id') id, @Req() req) {
    const csrfToken = req.csrfToken();

    const serviceProvider = await this.serviceProviderService.findById(id);
    const output = {
      ...serviceProvider,
      jwksUri: serviceProvider.jwks_uri,
      signupId: serviceProvider.signup_id,
      redirectUri: this.AddCarriageReturn(serviceProvider.redirect_uris),
      site: this.AddCarriageReturn(serviceProvider.site),
      ipsRanges: this.AddCarriageReturn(
        serviceProvider.IPServerAddressesAndRanges,
      ),
      postLogoutUri: this.AddCarriageReturn(
        serviceProvider.post_logout_redirect_uris,
      ),
      emails: Array.isArray(serviceProvider.email)
        ? this.AddCarriageReturn(serviceProvider.email)
        : this.formatEmailFields(serviceProvider.email),
      idpFilterExclude: serviceProvider.idpFilterExclude ?? true,
      idpFilterList: serviceProvider.idpFilterList || [],
    };

    /**
     * We want to send to the view all the fields that the user
     * has updated if there was an error plus all the fields
     * that were not updated.
     */
    if (req.session.flash && req.session.flash.errors) {
      Object.assign(req.session.flash.values[0], output);
    } else {
      req.flash('values', output);
    }

    const scopesSelected: string[] = serviceProvider.scopes || [];
    const scopesGroupedByFd = await this.scopesService.getScopesGroupedByFd();

    const claimsSelected: string[] = serviceProvider.claims || ['amr'];
    const claims: Claims[] = await this.claimsService.getAll();

    const identityProviders: IIdentityProvider[] = await this.identityProviderService.getAll();
    const representativeScopeList = this.serviceProviderService.getRepresentativeScopeList();

    const response = {
      csrfToken,
      id,
      identityProviders,
      claimsSelected,
      claims,
      scopesGroupedByFd,
      scopesSelected,
      representativeScopeList,
    };

    return response;
  }

  /**
   *
   * @param serviceProviderUpdate
   * @param id
   * @param req
   * @param res
   */
  @Patch(':id')
  @Roles(UserRole.OPERATOR)
  @UseInterceptors(new FormErrorsInterceptor(`/service-provider/:id`))
  @UsePipes(new ValidationPipe({ transform: true, whitelist: true }))
  async serviceProviderUpdate(
    @Body() serviceProviderUpdate: ServiceProviderDto,
    @Param('id') id,
    @Req() req,
    @Res() res,
  ) {
    try {
      await this.serviceProviderService.update(
        id,
        serviceProviderUpdate,
        req.user.username,
      );
    } catch (error) {
      req.flash('globalError', 'Impossible de mettre à jour le FS');
      return res.redirect(`${res.locals.APP_ROOT}/service-provider/${id}`);
    }
    req.flash(
      'success',
      `Le fournisseur de service ${serviceProviderUpdate.name} a été modifié avec succès !`,
    );

    return res.redirect(`${res.locals.APP_ROOT}/service-provider/${id}`);
  }

  /**
   *
   * @param key
   * @param req
   * @param res
   * @param body
   */
  @Delete(':id')
  @Roles(UserRole.OPERATOR)
  @UseInterceptors(new FormErrorsInterceptor('/service-provider'))
  async deleteServiceProvider(
    @Param('id') id: string,
    @Req() req,
    @Res() res,
    @Body() body,
  ) {
    try {
      await this.serviceProviderService.deleteServiceProviderById(
        id,
        req.user.username,
      );
    } catch (error) {
      req.flash('globalError', error.message);
      return res.status(500);
    }
    req.flash(
      'success',
      `Le fournisseur de service ${body.name} a été supprimé avec succès !`,
    );
    return res.redirect(`${res.locals.APP_ROOT}/service-provider`);
  }

  /**
   *
   * @param deleteServiceProviderDto
   * @param res
   * @param req
   */
  @Post('delete')
  @Roles(UserRole.OPERATOR)
  @UsePipes(new ValidationPipe({ transform: true }))
  @UseInterceptors(new FormErrorsInterceptor('/service-provider'))
  async deleteServiceProviders(
    @Body() body: DeleteServiceProviderDto,
    @Res() res,
    @Req() req,
  ) {
    const { deleteItems = [], name } = body;
    try {
      await this.serviceProviderService.deleteManyServiceProvidersById(
        deleteItems,
        req.user.username,
      );
    } catch (error) {
      req.flash('globalError', error.message);
      return res.status(500);
    }
    req.flash(
      'success',
      `Les fournisseurs de service ${name} ont été supprimés avec succès !`,
    );
    return res.redirect(`${res.locals.APP_ROOT}/service-provider`);
  }

  /**
   *
   * @param id
   * @param req
   * @param res
   */
  @Get('update/:id/secret')
  @Roles(UserRole.OPERATOR)
  @Render('service-provider/generate-new-client-secret')
  async generateNewSecret(@Param('id') id: string, @Req() req, @Res() res) {
    const csrfToken = req.csrfToken();

    /**
     * If we have an error to flash, we want to render the last user inputs,
     * not the service-provider in database.
     */
    if (req.session.flash && req.session.flash.errors) {
      return {
        csrfToken,
        id,
      };
    }

    const serviceProvider = await this.serviceProviderService.findById(id);
    return {
      csrfToken,
      id,
      messages: {
        values: [serviceProvider],
      },
    };
  }

  /**
   *
   * @param id
   * @param generateNewClientSecretDTO
   * @param req
   * @param res
   */
  @Patch('update/:id/secret')
  @Roles(UserRole.OPERATOR)
  @UseInterceptors(
    new FormErrorsInterceptor('/service-provider/update/:id/secret'),
  )
  async generateNewClientSecret(
    @Param('id') id: string,
    @Body() generateNewClientSecretDTO: GenerateNewClientSecretDTO,
    @Req() req,
    @Res() res,
  ) {
    try {
      await this.serviceProviderService.generateNewSecret(
        id,
        req.user.username,
      );
    } catch (error) {
      req.flash('gobalError', error);
      return res.status(500);
    }

    req.flash(
      'success',
      `Le nouveau client secret du fournisseur de service ${generateNewClientSecretDTO.name} a été généré avec succés !`,
    );

    return res.redirect(`${res.locals.APP_ROOT}/service-provider`);
  }

  private AddCarriageReturn(input: string[]) {
    if (Array.isArray(input)) {
      return input.join('\r\n');
    }
    return input;
  }

  private formatEmailFields(emails: string): string {
    if (typeof emails !== 'string') {
      return '';
    }
    return emails.replace(/,/g, '\r\n');
  }
}
